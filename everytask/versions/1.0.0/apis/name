'''
On récupère la data+heure de création (epoch) du temp de l'index (on le créer si il n'existe pas)
Si il a été modifié il y a moins de deux heures,on le modifie pas
Sinon: on l'update

On va ensuite créer l'index: 
On récupère l'index des applis avec:
- la config
- le code source (juste l'architecture + sha/path des fichiers pour récupérer le contenu)
- Les ressources (juste les données avec le sha/path pour récupérer le contenu)
- La documentation
- Les commentaires
'''


try:
    from .DataAPI import DataAPI
    from .GFM import GithubFileManager
except:
    from DataAPI import DataAPI
    from GFM import GithubFileManager

import os
import json
import time
import threading
import random
from string import ascii_letters
import shutil
import glob
import bcrypt
import platform
import base64
import uuid

def read_json(path):
    with open(path , "r" , encoding="utf8") as f:
        return json.loads(f.read())


def write_json(path , data):
    with open(path , "w" , encoding="utf8") as f:
        f.write(json.dumps(data , ensure_ascii=False , indent=4))


sep = "/" if "/" in __file__ else "\\"
api_directory = "/".join(__file__.split(sep)[0:-1]) + "/"
everytask_directory = "/".join(__file__.split(sep)[0:-2]) + "/"



'''


- Install Application (application_id , version , user, environnement)
    On vérifie que l'application existe
    On vérifie que la version exsiste
    On récupère le sha du dossier de la version
    On télécharge dans un dossier nommé Name-UUID.split("-")[0]
    On créer le fichier IndexConfig.bin

- Uninstall Application (application_id , user , environnement)
    On vérifie que l'application existe localement grace a locally exsists
    On supprime le dossier

- Check Update (application_id , user , enviroennement)
    On vérifie que l'application existe localement grace a locally exsists
    On récupère la version local et la compare a la dernière version dans l'index, Si La version de l'index est supérieur, update sinon pas d'update

- Update Application (application_id , version , user , environnement)
    (L'update peut se faire dans les deux sens, on peut préferer l'ancienne version et donc choisir celle ci)
    On vérifie que l'application exsiste localement grace a locally exists
    On supprime tous les fichiers et les remplacent par les nouveaux, Grace au dossier applicationsData, on sait que toutes les données utilisateurs ne sont pas la

- Get Source Code



- Upload Application #OK
- New Application Update #OK
- Remove Application #OK

- New Developpement #SHA #Developpements.json #OK

- New Report #SHA #Reports.json #OK

- New review #SHA #Reviews.json #OK

- Generate Key #OK
- Get Computer ID #OK
- Check Application Permission #OK

- New Ressource Type #SHA Ressource Index
- Delete Resource Type #SHA #Ressource Index
- Upload Resource
- Delete Resource

- Search
'''



def generate_id(n=15 , notinthis=None , tries=0 , max_tries=5 , auth_chars=["number" , "letter" , "special"]):
        
        chars = ""
        if "number" in auth_chars: chars += "".join([str(x) for x in range(9)])
        if "letter" in auth_chars: chars += ascii_letters
        if "special" in auth_chars: chars + "".join(["_"])

        if chars == "": return None
        
        id_ = "".join([random.choice(chars) for x in range(n)])

        if isinstance(notinthis , (list,tuple,dict)):
            if id_ in notinthis and tries < max_tries:
                return generate_id(n , notinthis , tries + 1 , max_tries , auth_chars)
            if id_ in notinthis:
                return None
        
        return id_



class BindManager():

    def __init__(self , sequences):
        
        self.__binds = {}
        self.__sequences = sequences

        {self.__binds.update( {x: {}} ) for x in self.__sequences}
    

    def bind(self , sequence , function=None , function_args=None , function_kwargs=None , **kwargs):
        
        if sequence not in self.__sequences:
            return
        
        if function.__class__.__name__ not in ["function" , "method" , "class" , "builtin_function_or_method"]:
            return
        
        function_args = () if function_args is None else function_args
        if isinstance(function_args , tuple) == False:
            return
        
        function_kwargs = {} if function_kwargs is None else function_kwargs
        if isinstance(function_kwargs , dict) == False:
            return
        
        bind_id = generate_id(n=15 , notinthis=list(self.__binds))

        bind = {
            "id":bind_id,
            "sequence": sequence,
            "function":function , "args":function_args , "kwargs":function_kwargs
        }
        self.__binds[sequence][bind_id] = bind

        return bind_id


    def execute_bind(self , sequence=None , bind_id=None , data=None):
        
        if sequence is not None and sequence not in self.__binds:
            return
        
        if bind_id is not None and self.get_bind_by_id(bind_id) is None:
            return
        
        if bind_id is not None:
            binds = [bind_id]
        else:
            binds = list(self.__binds[sequence])
        
        binds = [bind_id] if bind_id is not None else self.__binds[sequence]
        
        for k in binds:
            bind = self.get_bind_by_id(k)
            threading.Thread(target=bind["function"] , args=(data, *bind["args"]) , kwargs=bind["kwargs"]).start()
        
    
    def get_bind_by_id(self , bind_id):
        
        for sequence in self.__binds:
            if bind_id in self.__binds[sequence]:
                return self.__binds[sequence][bind_id]


    def unbind(self , bind_id):
        for sequence in self.__binds:
            if bind_id in self.__binds[sequence]:
                self.__binds[sequence].pop(bind_id)
                return True
        return False
    

    def unbind_all(self):
        
        for sequence in self.__binds:
            for bind_id in self.__binds[sequence]:
                self.unbind(bind_id)



class Downloader(threading.Thread):
    
    def __init__(self , api , local_path , download_type = "application" , application_id = None, **kwargs):
        '''
        Class to download applications and resources.
        
        param api: AppIndexAPI
        param local_path: path to download the folder
        param download_type: type of the upload (application / resource) 
        
        #FOR BOTH TYPE
        param application_id: id of the application
        
        #FOR APPLICATION DOWNLOAD
        param application_version: version of the application
        
        #FOR RESOURCE DOWNLOADS
        param resource_type: type of the resource
        param resource_id: id of the resource
        '''
    
        threading.Thread.__init__(self)

        self.github_file_manager = GithubFileManager(api_directory + "GithubFileManager.exe")

        self.api = api
        self.__index = self.api.get_index()

        self.local_path = local_path
        self.download_type = download_type

        self.application_id = application_id
        self.application_version = kwargs.get("application_version" , None)

        self.resource_type = kwargs.get("resource_type" , None)
        self.resource_id = kwargs.get("resource_id" , None)

        self.bindManager = BindManager(["<Progress>"])

        self.active = True

        self.progress = {}

        self.settings_check = self.check_settings()

        
        
        
    
    def run(self):

        if self.settings_check == False:
            return
        
        if self.download_type == "application":
            
            sha = self.github_file_manager.get_directory_sha("Applications/{}/versions/{}/".format(self.application_id , self.application_version))

            tree_path = "Applications/{}/versions/{}".format(self.application_id , self.application_version)

            self.local_path = self.local_path + self.__index[self.application_id]["name"] + "_" + self.application_id.split("-")[0] + "/"

        elif self.download_type == "resource":
            
            #resource_types = self.__index[self.application_id]["resource_types"]
            
            sha = self.github_file_manager.get_directory_sha("Applications/{}/resources/{}/{}/".format(self.application_id , self.resource_type , self.resource_id))

            tree_path = "Applications/{}/resources/{}/{}".format(self.application_id , self.resource_type , self.resource_id)
            
        tree = self.github_file_manager.get_diectory(sha)
        
        self.progress["total"] = sum([len(tree[x]["files"]) for x in tree])

        for path in tree:

            if os.path.exists(self.local_path[0:-1] + path) == False:
                os.system('mkdir "{}"'.format(self.local_path[0:-1] + path + "/"))
            
            for file in tree[path]["files"]:
                self.github_file_manager.download_file(tree_path + file["github_path"] , local_path = self.local_path[0:-1] + path + "/")
                self.progress["progress"] += 1
                self.bindManager.execute_bind("<Progress>" , data = self.progress)

        if self.download_type == "application":
            index_config = self.github_file_manager.download_file("Applications/" + self.application_id + "/IndexConfig.json")
            index_config.update({"version": self.application_version})
            write_json(self.local_path + "/config.json", index_config)
            application_data_path = self.local_path.replace("/applications/" , "/applicationsData/")
            if os.path.exists(application_data_path) == False:
                os.system('mkdir "{}"'.format(application_data_path))
        

        self.bindManager.unbind_all()


    def check_settings(self):
        '''
        Application: Application_id + application version
        Resource: Application_id + resource_type + resource_id
        '''

        if self.application_id is None or self.application_id not in self.__index:
            return False

        if self.download_type == "application":
            if self.application_version is None or self.application_version not in self.__index[self.application_id]["versions"]:
                return False

        if self.download_type == "resource":
            if self.__index[self.application_id]["allow_resources"] == False:
                return False
            if self.resource_type is None or self.resource_type not in self.__index[self.application_id]["resources_types"]:
                return False
            resources = self.api.get_resources(self.application_id , resource_type = self.resource_type)
            if self.resource_id is None or self.resource_id not in resources:
                return False
        
        if os.path.exists(self.local_path) == False or os.path.isdir(self.local_path) == False:
            return False

        self.progress = {
            "name": self.__index[self.application_id]["name"] if self.download_type == "application" else self.resource_id,
            "progress": 0,
            "total": 0
        }

        return True


    def bind(self , *args , **kwargs):
        self.bindManager.bind(*args , **kwargs)













class Uploader(threading.Thread):

    def __init__(self , api , local_path = None , upload_type = "application" , **kwargs):
        
        threading.Thread.__init__(self)

        self.api = api
        self.__index = self.api.get_index()

        self.local_path = local_path
        self.upload_type = upload_type

        self.github_file_manager = GithubFileManager(api_directory + "GithubFileManager.exe")

        self.application_id = kwargs.get("application_id" , None)
        self.application_key = kwargs.get("application_key", None)
        self.application_password = kwargs.get("application_password" , None)
        self.application_version = kwargs.get("application_version", None)
        self.allow_resources = kwargs.get("allow_resources" , False)

        self.resource_type = kwargs.get("resource_type" , None)
        self.resource_id = kwargs.get("resource_id", None)
        
        self.config = kwargs.get("config" , None)

        self.bindManager = BindManager(["<Progress>"])

        self.active = True

        self.progress = {}

        self.error = None

        self.settings_check = self.check_settings()


    def run(self):

        if self.settings_check == False:
            return

        tree = None

        if self.upload_type == "application":

            if self.application_id not in self.__index:
                self.application_version = "1.0.0"
                self.__init_application()
                
            else:
                versions = self.__index[self.application_id]["versions"]
                if self.application_version in versions or self.application_version is None or len( self.application_version.split(".")) != 3:
                    latest_version = list(versions)[-1].split(".")
                    self.application_version = latest_version[0] + str(int(latest_version[1]) + 1) + "0"
            
            self.path = "Applications/" + self.application_id + "/versions/" + self.application_version + "/"

        elif self.upload_type == "resource":
            
            if os.path.isfile(self.local_path):
                self.path = "Applications/" + self.application_id + "/resources/" + self.resource_type + "/" + self.resource_id + "/"
                name = self.local_path.split("/")[-1]
                tree = {self.path: [{"path": self.local_path , "name": name}]}
            
            elif os.path.isdir(self.local_path):
                self.path = "Applications/" + self.application_id + "/resources/" + self.resource_type + "/" + self.resource_id + "/" + self.config["name"] + "/"

        if tree is None:
            tree = self.__get_local_tree()

        self.progress["total"] = sum([len(tree[x]) for x in tree])

        for path in tree:

            for file in tree[path]:
                
                self.progress["current_file"] = file

                with open(file["path"] , "rb") as f:
                    content = base64.b64encode(f.read()).decode("utf8")
                
                for k in range(3):
                    try:
                        self.github_file_manager.upload_file(path + file["name"] , content)
                        break
                    except: 
                        continue
                
                self.progress["progress"] += 1
                self.bindManager.execute_bind("<Progress>", data = self.progress)
        
        if self.upload_type == "application":
            
            #WRITE TO VERSION INDEX
            version = self.application_version
            version_index , sha = self.github_file_manager.download_file("Applications/" + self.application_id + "/versions/versions.json" , sha = True)
            version_index.update({
                version:{
                    "name": version,
                    "date": time.strftime("%d-%m-%Y" , time.localtime()),
                    "time": time.strftime("%H:%M", time.localtime()),
                    "epoch": time.time(),
                    "description": self.config.get("description", None)
                }
            })
            self.github_file_manager.upload_file(
                path = "Applications/" + self.application_id + "/versions/versions.json",
                content = base64.b64encode(json.dumps(version_index, ensure_ascii=False , indent=4).encode("utf8")).decode("utf8"),
                sha = sha
            )

            #WRITE TO APP INDEX
            if self.application_id not in self.__index:
                index , sha = self.github_file_manager.download_file("Applications/index.json" , sha = True)
                index[self.application_id] = {
                    "id": self.application_id,
                    "name": self.config["name"],
                    "author": self.config.get("author" , "Unknown"),
                    "description": self.config.get("description", None),
                    "allow_resources":self.allow_resources,
                    "search_tags": self.config.get("search_tags" , [])
                }
                index = base64.b64encode(json.dumps(index , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
                self.github_file_manager.upload_file("Applications/index.json" , content = index , sha = sha)

            if "coqcinq" in self.config and version != "1.0.0":
                ccq_sha =  self.github_file_manager.get_file_sha("Applications/" + self.application_id + "/IndexData/coqcinq.cqq")
                coqcinq = base64.b64encode(self.config["coqcinq"].encode("utf8")).decode("utf8")
                self.github_file_manager.upload_file("Applications/" + self.application_id + "/IndexData/coqcinq.ccq" , content = coqcinq , sha = ccq_sha)



        elif self.upload_type == "resource":

            #WRITE TO RESOURCE INDEX
            resource_type_index , sha = self.github_file_manager.download_file("Applications/" + self.application_id + "/resources/" + self.resource_type + "/index.json" , sha = True)
            resource_type_index.update({
                self.resource_id: {
                    "name": self.config["name"],
                    "description": self.config.get("description" , None)
                }
            })
            resource_type_index = base64.b64encode(json.dumps(resource_type_index , ensure_ascii=False , indent=4).encode("utf8")).decode("utf8")
            self.github_file_manager.upload_file("Applications/" + self.application_id + "/resources/" + self.resource_type + "/index.json" , content = resource_type_index , sha = sha)


        if self.upload_type == "application":
            self.api.update_local_index(self.application_id)
            self.__index = self.api.get_index()

        self.bindManager.unbind_all()


    def __init_application(self):
        
        app_master = "Applications/" + self.application_id + "/"

        #COQCINQ
        coqcinq = self.config.pop("coqcinq" , "")
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/coqcinq.ccq",
            content = base64.b64encode(coqcinq.encode("utf8")).decode("utf8")
        )

        #CONFIG
        if "description" not in self.config or isinstance(self.config["description"] , str) == False:
            self.config["description"] = None
        if "author" not in self.config or isinstance(self.config["author"] , str) == False:
            self.config["author"] = "Unknown"
        if "search_tags" not in self.config or isinstance(self.config["search_tags"] , list) == False:
            self.config["search_tags"] = []
        self.github_file_manager.upload_file(
            path = app_master + "config.json",
            content = base64.b64encode(json.dumps(self.config , indent = 4 , ensure_ascii = False).encode("utf8")).decode("utf8")
        )
        self.config.update({"version": self.application_version})
        write_json(self.local_path + "config.json" , self.config)

        #KEY
        key = {
            "application_key": self.application_key
        }
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/key.json",
            content = base64.b64encode(json.dumps(key , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #COMMENTS
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/reviews.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #REPORTS
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/reports.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #ISSUES
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/issues.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #SUGGESTIONS
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/suggestions.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #DEVELOPPEMENT
        self.github_file_manager.upload_file(
            path = app_master + "IndexData/developpement.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #VERSION INDEX
        self.github_file_manager.upload_file(
            path = app_master + "versions/versions.json",
            content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
        )

        #ressource
        if self.allow_resources == True:
            self.github_file_manager.upload_file(
                path = app_master + "resources/types.json",
                content = base64.b64encode(json.dumps({} , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")
            )
        
        self.api.update_local_index(self.application_id)
        self.__index = self.api.get_index()


    def __get_local_tree(self , path=None , data=None):
        """
        Get file list recursively from local_path 
        param path: current_path (None by default = self.local_path)
        param data: tree
        """

        if data is None: data = {}
        if path is None: path = self.local_path

        tree = [x.replace("\\" , "/") for x in glob.glob(path + "**")]
        folders = [x.replace(path , "") for x in tree if os.path.isdir(x) == True]

        tmp_path = path.replace(self.local_path , "")
        tmp_path = self.path + tmp_path

        data[tmp_path] = [{"path":x , "name":x.split("/")[-1]} for x in tree if os.path.isfile(x) == True]

        for k in folders:
            if k != "__pycache__":
                self.__get_local_tree(path + k + "/" , data)
        
        return data


    def check_settings(self):
        
        '''
        type: application / resource
        application: application_id n'existe pas
        si application_id existe, check computer
        '''

        if self.application_id is None:
            return False

        if self.upload_type == "application":

            if self.application_id in self.__index:

                if self.application_password is None:
                    return False

                password_check = self.api.check_password(self.application_id , self.application_password)
                if password_check == False:
                    return False
            
            else:

                if isinstance(self.allow_resources , bool) == False:
                    return False

                if "name" not in self.config:
                    return False
            
            is_application_valid = self.api.data_api.is_application_valid(self.local_path)

            if is_application_valid == False:
                return False
        
        
        elif self.upload_type == "resource":

            if self.application_id is None or self.application_id not in self.__index:
                return False
            
            if self.resource_type is None or "resources_types" not in self.__index[self.application_id] or self.resource_type not in self.__index[self.application_id]["resources_types"]:
                return False

            resources = self.api.get_resources(self.application_id , self.resource_type)
            
            if self.resource_id in resources:
                return False
            
            if "name" not in self.config:
                return False
            
        
        self.progress = {
            "name": self.application_id if self.upload_type == "application" else self.resource_id,
            "current_file": None,
            "progress": 0,
            "total": 0
        }
        
        return True


    def bind(self , *args , **kwargs):
        self.bindManager.bind(*args , **kwargs)

    


            
            
                
        




class AppIndexAPI():
    
    def __init__(self , user_directory = ""):
        
        self.user_directory = user_directory

        self.github_file_manager = GithubFileManager(api_directory + "GithubFileManager.exe")
        self.data_api = DataAPI(user_directory)

        self.__index = {}
        self.__index_load_time = None # dernier fois que l'api a load le fichier
        self.__index_update_time = None # dernier fois que le fichier a été mis a jour

        #self.check_index_update()
        #threading.Thread(target = self.update_local_index).start()
        self.load_index()

        self.active = True


    def get_index(self , reloadit = False):

        for app_id in self.__index:
            if "icon" not in self.__index[app_id]:
                icon = self.github_file_manager.download_file("Applications/" + app_id + "/versions/1.0.0/icon.png" , download_url=True)
                if icon == b'6\x89\xde':
                    icon = None
                self.__index[app_id]["icon"] = icon.decode("utf8")
        return self.__index



    def install_application(self , application_id , version , user , environnement):
        '''
        Return a downloader to download and install the application in user's environnement.
        This function is used to update the application
        '''

        if application_id not in self.__index:
            return
        
        if version not in self.__index[application_id]["versions"]:
            return

        users = self.data_api.get_users()

        if user not in users:
            return
        
        environnements = self.data_api.get_environnements(user)

        if environnement not in environnements:
            return

        #UNINSTALL if application is already INSTALLED
        self.uninstall_application(application_id , user , environnement , remove_application_data = False)

        return Downloader(self , local_path = self.user_directory + user + "/Environnements/" + environnement + "/applications/" , application_id = application_id , application_version = version)


    def get_application_coqcinq(self , application_id):
        coqcinq = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/coqcinq.ccq")
        if coqcinq != b'6\x89\xde':
            return coqcinq.decode("utf8")


    def check_application_update(self , application_id , user , environnement):
        '''
        Check if the application is up to date
        '''
        
        if application_id not in self.__index:
            return
        
        check = self.data_api.check(user , environnement , application_id)
        
        if check == False:
            return

        application = self.data_api.get_environnements(user , environnement)["applications"][application_id]

        version = application["version"]

        latest_version = list(self.__index[application_id]["versions"])[-1]

        if version != latest_version:
            return True
        
        return False
    

    def check_local_application(self , application_id , user , environnement):

        if application_id not in self.__index:
            return False
        
        return self.data_api.check(user , environnement , application_id)
    

    def uninstall_application(self , application_id , user , environnement , remove_application_data = True):

        if application_id not in self.__index:
            return
        
        check = self.data_api.check(user , environnement , application_id)

        if check == False:
            return

        application = self.data_api.get_environnements(user , environnement)["applications"][application_id]

        shutil.rmtree(application["path"])
        
        if remove_application_data == True:

            data_path = application["path"].replace("/applications/" , "/applicationsData/")

            if os.path.exists(data_path):
                shutil.rmtree(data_path)


    def generate_key(self , password):
        '''
        Generate hash from password for applications auth
        '''
        
        if isinstance(password , str) == False:
            return
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode("utf8") , salt)

        return hashed
    

    def check_password(self , application_id , password = None):
        '''
        Check if password correspond to the application's password
        '''
        if application_id not in self.__index:
            return
        
        if isinstance(password , str) == False:
            return
        
        content = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/key.json")
        
        hashed_key = content["application_key"]

        return bcrypt.checkpw(password.encode("utf8") , hashed_key.encode("utf8"))


    def get_password_from_user_data(self , application_id , user = None):
        '''
        Get passwords from user data, prevent from always give the password
        '''

        users = self.data_api.get_users()

        if user not in users:
            return
        
        if application_id in users[user]["apps-passwords"]:
            return users[user]["apps-passwords"][application_id]
    


    def get_user_id(self , user):
        _user = self.data_api.get_users(user)
        if _user is not None:
            return _user["userid"]



    def upload_application(self , application_path = None , password = None , name = None , author = None , description = None , coqcinq = None , search_tags = None , allow_resources = False):
        '''
        Upload an application to the Index
        '''
        
        is_valid = self.data_api.is_application_valid(application_path)

        if is_valid == False:
            return
        
        application_id = str(uuid.uuid4())
        key = self.generate_key(password).decode("utf8")

        config = {
            "name": name,
            "author": author,
            "description": description,
            "coqcinq": coqcinq,
            "id": application_id,
            "search_tags": search_tags
        }

        return Uploader(self , application_path , upload_type = "application" , application_id = application_id , allow_resources = allow_resources , config = config , application_key = key)



    def update_application(self , application_path = None , application_id = None, version = None , password = None , description = None , coqcinq = None):
        '''
        update an application from the index
        '''
        
        is_valid = self.data_api.is_application_valid(application_path)

        if is_valid == False:
            return

        password_check = self.check_password(application_id , password)

        if password_check == False:
            return
        
        if description is not None and isinstance(description , str) == False:
            description = None 

        config = {
            "description": description
        }
        if coqcinq is not None:
            config.update({"coqcinq": coqcinq})

        return Uploader(self , application_path , upload_type = "application" , application_id = application_id , application_version = version , config = config , application_password = password)




    def delete_application(self , application_id = None, password = None):
        '''
        Delete an application from the index
        '''
        
        if application_id not in self.__index:
            return
        
        password_check = self.check_password(application_id , password)

        if password_check == False:
            return
        
        sha = self.github_file_manager.get_directory_sha("Applications/{}/".format(application_id))

        self.github_file_manager.delete_directory(sha , "Applications/{}/".format(application_id))

        self.update_local_index(application_id)
    


    def new_developpement(self , application_id = None , password = None , content = None):
        
        if application_id not in self.__index:
            return
        
        password_check = self.check_password(application_id , password)

        if password_check == False:
            return
        
        developpement , sha = self.github_file_manager.download_file("Applications/{}/IndexData/developpement.json".format(application_id) , sha = True)

        epoch = time.time()

        developpement.update({
            epoch: content
        })
        
        content = base64.b64encode(json.dumps(developpement , ensure_ascii = False , indent = 4).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/{}/IndexData/developpement.json".format(application_id) , content = content , sha = sha)

        self.update_local_index(application_id)
    


    def get_developpement(self , application_id = None):

        if application_id not in self.__index:
            return
        
        developpement = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/developpement.json")
        
        return developpement


    def new_issue(self , application_id = None , version = None , name = None , content = None , user = None , display_name = None):
        
        if application_id not in self.__index:
            return
        
        if version not in self.__index[application_id]["versions"]:
            return

        issues , sha = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/issues.json" , sha = True)

        issue_id = str(uuid.uuid4())

        user_id = self.get_user_id(user)

        if user_id is None:
            return

        current_date = time.strftime("%d/%m/%Y" , time.localtime())
        current_time = time.strftime("%H:%M" , time.localtime())

        issues.update({
            issue_id:{
                "id": issue_id,
                "username": display_name,
                "user": user_id,
                "version": version,
                "name": name,
                "content": content,
                "date": current_date,
                "time": current_time,
                "epoch": time.time(),
                "answers": {}
            }
        })

        issues = base64.b64encode(json.dumps(issues , ensure_ascii=False , indent=4).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/" + application_id + "/IndexData/issues.json" , content = issues , sha = sha)

    
    def get_issues(self , application_id = None , version = None):
        
        if application_id not in self.__index:
            return
        
        issues = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/issues.json")

        if version is None or version not in self.__index[application_id]["versions"]:
            return issues

        return {x: issues[x] for x in issues if issues[x]["version"] == version}


    def answer_issue(self , application_id = None , issue_id = None , content = None, user = None , display_name = None):

        if application_id not in self.__index:
            return
        
        if user is None:
            return
        
        issues , sha = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/issues.json" , sha = True)

        if issue_id not in issues:
            return
        
        current_date = time.strftime("%d/%m/%Y" , time.localtime())
        current_time = time.strftime("%H:%M" , time.localtime())
        
        answer_id = str(uuid.uuid4())

        user_id = self.get_user_id(user)

        if user_id is None:
            return

        issues[issue_id]["answers"][answer_id] = {
            "username": display_name,
            "user": user_id,
            "content": content,
            "date": current_date,
            "time": current_time,
            "epoch": time.time(),
            "score": {}
        }

        issues = base64.b64encode(json.dumps(issues , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/" + application_id + "/IndexData/issues.json" , content = issues , sha = sha)



    def score_issue_answer(self , application_id = None , issue_id = None , answer_id = None , score = 1 , user = None):
        
        if application_id not in self.__index:
            return False
        
        issues , sha = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/issues.json" , sha = True)

        if issue_id not in issues:
            return False
        
        if answer_id not in issues[issue_id]["answers"]:
            return False
        
        if score not in [-1 , 0 , 1]:
            return False
        
        if user is None:
            return False
        
        user_id = self.get_user_id(user)
        
        if user_id is None:
            return
        
        if score == 0:
            issues[issue_id]["answers"][answer_id]["score"].pop(user_id , None)
        else:
            issues[issue_id]["anwsers"][answer_id]["score"][user_id] = score
        
        issues = base64.b64encode(json.dumps(issues , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/" + application_id + "/IndexData/issues.json" , content = issues , sha = sha)
        
        return True




    def new_suggestion(self , application_id = None , name = None , content = None , user = None , display_name = None):
        
        if application_id not in self.__index:
            return
        
        if user is None:
            return

        suggestions , sha = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/suggestions.json" , sha = True)
        
        suggestion_id = str( uuid.uuid4() )

        user_id = self.get_user_id(user)

        if user_id is None:
            return

        current_date = time.strftime("%d/%m/%Y" , time.localtime())
        current_time = time.strftime("%H:%M" , time.localtime())

        suggestions.update({
            suggestion_id:{
                "username": display_name,
                "user": user_id,
                "id": suggestion_id,
                "name": name,
                "content": content,
                "date": current_date,
                "time": current_time,
                "score": {}
            }
        })

        suggestions = base64.b64encode(json.dumps(suggestions, ensure_ascii=False , indent=4).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/" + application_id + "/IndexData/suggestions.json" , content = suggestions , sha = sha)



    def get_suggestions(self , application_id = None , sort_method = "name" , sort_order = "ascent"):
        
        if application_id not in self.__index:
            return
        
        suggestions = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/suggestions.json")

        ids = list(suggestions)

        if sort_method == "name":
            ids = sorted(ids , key=lambda e: suggestions[e]["name"])
        
        elif sort_method == "up":
            ids = sorted(ids, key = lambda e: suggestions[e]["up"])
        
        if sort_order == "descent":
            ids.reverse()
        
        return {x:suggestions[x] for x in ids}
    


    def score_suggestion(self , application_id = None , suggestion_id = None , score = 1 , user = None):
        
        if application_id not in self.__index:
            return
        
        suggestions , sha = self.github_file_manager.download_file("Applications/" + application_id + "/IndexData/suggestions.json" , sha = True)

        if suggestion_id not in suggestions:
            return

        if user is None:
            return False
    
        if score not in [1 , 0 , -1]:
            return
        
        user_id = self.get_user_id(user)

        if user_id is None:
            return

        if score == 0:
            suggestions[suggestion_id]["score"].pop(user_id , None)
        else:
            suggestions[suggestion_id]["score"][user_id] = score

        suggestions = base64.b64encode(json.dumps(suggestions , ensure_ascii=False , indent=4).encode("utf8")).decode("utf8")

        self.github_file_manager.upload_file("Applications/" + application_id + "/IndexData/suggestions.json" , content = suggestions , sha = sha)



    def new_report(self , application_id = None, version = "1.0.0" , content = None , user = None):
        
        if application_id not in self.__index:
            return
        
        if version not in self.__index[application_id]["versions"]:
            return
        
        if isinstance(content , str) == False and content is not None:
            content = None
        
        if isinstance(user , str) == False:
            return
        
        '''reports , sha = self.github_file_manager.download_file("Applications/" + application_id + )'''
        



    def new_review(self , application_id = None , version = "1.0.0" , title = "Untilted" , content = None , note = None , user = None ,  display_name = None):
        
        if application_id not in self.__index:
            return
        
        if version not in self.__index[application_id]["versions"]:
            return
        
        if isinstance(title , str) == False:
            title = "Untilted"

        if isinstance(content , str) == False:
            content = None

        if isinstance(note, (int , float)) == False:
            note = None

        if content is None and note is None:
            return
                
        reviews , sha = self.github_file_manager.download_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , sha = True)
        
        user_id = self.get_user_id(user)
        
        review_id = [x for x in reviews if reviews[x]["user_id"] == user_id]
        if review_id == []:
            salt = bcrypt.gensalt()
            review_id = str(uuid.uuid4())
            reviews[review_id] = {
                "id": review_id,
                "display_name": display_name,
                "user_id": user_id,
                "key": bcrypt.hashpw(user_id.encode("utf8") , salt).decode("utf8"),
                "versions": {}
            }
        else: 
            review_id = review_id[0]
            keycheck = bcrypt.checkpw(user_id.encode("utf8") , reviews[review_id]["key"].encode("utf8"))
            if keycheck == False:
                return

        current_time = time.strftime("%H:%M", time.localtime())
        current_date = time.strftime("%d/%m/%Y" , time.localtime())
        
        if version not in reviews[review_id]["versions"]:
            reviews[review_id]["versions"][version] = {
                "version": version,
                "history": []
            }
        
        reviews[review_id]["versions"][version]["history"].append({
            "version": version,
            "title": title,
            "content": content,
            "note": note,
            "date": current_date,
            "time": current_time,
            "epoch": time.time(),
            "score": {}
        })

        reviews = base64.b64encode(json.dumps(reviews , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")

        return self.github_file_manager.upload_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , content = reviews , sha = sha)
    


    def get_reviews(self , application_id , version = None):

        if application_id not in self.__index:
            return
        
        reviews = self.github_file_manager.download_file(path = "Applications/" + application_id + "/IndexData/reviews.json")

        if version is None:
            return reviews

        tmp = reviews
        reviews = {}

        for k in tmp:
            if version in tmp[k]["versions"]:
                d = tmp[k]
                d.update({
                    "review": tmp[k]["versions"][version]
                })
                d.pop("versions")
                reviews[k] = d
        
        return reviews


    def delete_review(self, application_id , review_id , user = None):
        
        if application_id not in self.__index:
            return
        
        reviews , sha = self.github_file_manager.download_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , sha = True)

        if review_id not in reviews:
            return
        
        user_id = self.get_user_id(user)

        if user_id is None:
            return
        
        keycheck = bcrypt.checkpw(user_id.encode("utf8") , reviews[review_id]["key"].encode("utf8"))

        if keycheck == False:
            return
        
        reviews.pop(review_id)

        reviews = base64.b64encode(json.dumps(reviews , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")

        return self.github_file_manager.upload_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , content = reviews , sha = sha)
        


    def score_review(self , application_id , version = None , review_id = None , user = None , score = None):
        
        if score not in [-1 , 0 , 1]:
            return

        if application_id not in self.__index:
            return
        
        reviews , sha = self.github_file_manager.download_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , sha = True)

        if review_id not in reviews:
            return
        
        user_id = self.get_user_id(user)

        if user_id is None:
            return
        
        if version not in reviews[review_id]["versions"]:
            return
        
        if score == 0: 
            reviews[review_id]["versions"][version]["history"][-1]["score"].pop(user_id , None)
        else:
            reviews[review_id]["versions"][version]["history"][-1]["score"][user_id] = score

        reviews = base64.b64encode(json.dumps(reviews , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")

        return self.github_file_manager.upload_file(path = "Applications/" + application_id + "/IndexData/reviews.json" , content = reviews , sha = sha)



    def asnwer(self , application_id = None , _type = None , master = None):
        pass












        
        
        



    def new_resource_type(self , application_id = None , password = None , name = None , description = None , path = None , source_type = None):
        
        if application_id not in self.__index:
            return
        
        if "resources_types" not in self.__index[application_id]:
            return
        
        if isinstance(name , str) == False:
            return
        
        if isinstance(source_type , list) == False:
            source_type = ["file", "folder"]
        source_type = [x for x in source_type if x in ["file", "folder"]]

        password_check = self.check_password(application_id , password)

        if password_check == False:
            return
        
        sha = self.github_file_manager.get_file_sha(path = "Applications/" + application_id + "/resources/types.json")
        resource_types = self.__index[application_id]["resources_types"]

        resource_types[name] = {
            "name": name,
            "description": description,
            "path": path,
            "source_type": source_type
        }

        resource_types = base64.b64encode(json.dumps(resource_types , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")
        self.github_file_manager.upload_file("Applications/" + application_id + "/resources/types.json" , content = resource_types , sha = sha)

        index = base64.b64encode(json.dumps({} , indent=4 , ensure_ascii=False).encode("utf8")).decode("utf8")
        self.github_file_manager.upload_file("Applications/" + application_id + "/resources/" + name + "/index.json" , content = index)
        
        self.update_local_index(application_id)


    def delete_resource_type(self , application_id = None , password = None , name = None):
        
        if application_id not in self.__index:
            return
        
        if "resources_types" not in self.__index[application_id]:
            return
        
        if isinstance(name , str) == False or name not in self.__index[application_id]["resources_types"]:
            return
        
        password_check = self.check_password(application_id , password)

        if password_check == False:
            return
        
        sha = self.github_file_manager.get_file_sha(path = "Applications/" + application_id + "/resources/types.json")
        
        resources_types = self.__index[application_id]["resources_types"]
        
        resources_types.pop(name , None)

        resources_types = base64.b64encode(json.dumps(resources_types , indent = 4 , ensure_ascii = False).encode("utf8")).decode("utf8")
        self.github_file_manager.upload_file(path = "Applications/" + application_id + "/resources/types.json" , content = resources_types , sha = sha)

        sha = self.github_file_manager.get_directory_sha(path = "Applications/" + application_id + "/resources/" + name + "/")
        self.github_file_manager.delete_directory(sha , path = "Applications/" + application_id + "/resources/" + name)

        self.update_local_index(application_id)



    def upload_resource(self, application_id = None , resource_type = None , resource_path = None, description = None  ):
        
        if application_id not in self.__index:
            return
        
        if self.__index[application_id]["allow_resources"] == False:
            return
        
        if os.path.exists(resource_path) == False:
            return
        
        if resource_type not in self.__index[application_id]["resources_types"]:
            return

        resource_id = str( uuid.uuid4() )

        name = resource_path.split("/")
        if os.path.isfile(resource_path):
            name = ".".join(resource_path.split("/")[-1].split(".")[0:-1])
        elif os.path.isdir(resource_path):
            name = [x for x in resource_path.split("/") if x.strip() != ""][-1]

        config = {
            "name": name,
            "description": description
        }

        return Uploader(self , resource_path , "resource" , application_id = application_id , resource_id = resource_id , resource_type = resource_type , config = config)




    def download_resource(self , application_id = None , resource_type = None , resource_id = None , user = None , environnement = None):

        if application_id not in self.__index:
            return

        data_api_check = self.data_api.check(user , environnement , application_id)

        if data_api_check == False:
            return
        
        app_data_path = self.data_api.get_environnements(user , environnement)["applications"][application_id]["app_data_path"]

        if self.__index[application_id]["allow_resources"] == False:
            return
        
        if resource_type not in self.__index[application_id]["resources_types"]:
            return
        
        resources = self.get_resources(application_id , resource_type=resource_type)

        if resource_id not in resources:
            return
        
        resource_path = self.__index[application_id]["resources_types"][resource_type]["path"]
        if resource_path is None: resource_path = ""
        local_path = app_data_path + resource_path
        if local_path.endswith("/") == False:
            local_path += "/"
        if os.path.exists(local_path) == False:
            os.system('mkdir "{}"'.format(local_path))

        return Downloader(self , local_path, "resource" , application_id , resource_type = resource_type , resource_id = resource_id)


    def get_resources(self , application_id , resource_type = None , only_types = False):
            
        if application_id not in self.__index:
            return

        if self.__index[application_id]["allow_resources"] == False:
            return
        
        types = self.github_file_manager.download_file("Applications/" + application_id + "/resources/types.json")

        if only_types == True:
            return types

        if resource_type is not None:
            
            if resource_type not in types:
                return
            
            types = [resource_type]

        resources = {}
        for t in types:
            resources[t] = self.github_file_manager.download_file("Applications/" + application_id + "/resources/" + t + "/index.json")
        
        if resource_type is not None:
            return resources[resource_type]
        return resources
        


    def search(self , search=None , sort_method="name" , sort_order="ascent" , update_index=False):
        
        """ Search app on the Application Index (https://github.com/antonin-acd-applications/Everytask-Applications-Index)
        param search: String for relevant results or None for all results
        """

        results = {}

        for item in self.__index:

            if search == "" or search is None:
                results[item] = self.__index[item]
                continue

            if search in item or item.startswith(search):
                results[item] = self.__index[item]
                continue

            for k in self.__index[item]["search_tags"]: 
                if search == k or k.startswith(search):
                    results[item] = self.__index[item]
                    break
        
        
        if sort_method == "name":
            results = sorted(results , key=lambda e: results[e]["name"])
        
        elif sort_method == "note":
            results = sorted(results , key=lambda e: results[e]["score"])

        elif sort_method == "review_count":
            results = sorted(results , key=lambda e: results[e]["review_count"])

        if sort_order == "descent":
            results.reverse()
            
        return results



    def search_v2(self , application_id = None , resource_type = None , search = None , sort_method = "name" , sort_order = "ascent"):
        '''
        
        '''

        if (application_id is not None and application_id not in self.__index) or self.__index[application_id]["allow_resources"] == False or (resource_type is not None and resource_type not in self.__index[application_id]["resources_types"]):
            return

        if application_id is not None:
            resources = self.get_resources(application_id , resource_type)
            items = []





    def check_index_update(self):
        
        if os.path.exists("tmp/AppIndex.json") == False:
            self.update_local_index()
            self.load_index()
            return
        
        ctime = time.time()

        if self.__index_update_time is None and self.__index_load_time is None:
            mtime = os.path.getmtime("tmp/AppIndex.json")    
            if ctime > mtime + 2 * 3600:
                self.update_local_index()
        else:
            if ctime > self.__index_update_time + 2 * 3600:
                self.update_local_index()
            
        self.load_index()

    

    def update_local_index(self , application_id = None):
        
        def get_versions(app_id):
            versions = self.github_file_manager.download_file("Applications/" + app_id + "/versions/versions.json")
            return versions
        
        def get_resources_types(app_id):
            return self.get_resources(app_id , only_types = True)
            
        def get_review_stats(app_id):
            reviews = self.github_file_manager.download_file("Applications/" + app_id + "/IndexData/reviews.json")
            notes = [reviews[x]["versions"][list(reviews[x]["versions"])[-1]]["note"] for x in reviews if reviews[x]["versions"][list(reviews[x]["versions"])[-1]]["note"] is not None]
            if notes != []: score = round(sum(notes) / len(notes))
            else: score = 0
            return {"score": score , "review_count": len(reviews)}

        def get(app_id):
            versions = get_versions(app_id)
            resources_types = get_resources_types(app_id)
            index[app_id].update({"versions": versions , "resources_types": resources_types} )
            review_stats = get_review_stats(app_id)
            index[app_id].update(review_stats)
            
        index = {}

        non_local_index = self.github_file_manager.download_file("Applications/index.json")
        if application_id is None:
            index = non_local_index
            applications = list(non_local_index)
        else:
            index = self.__index
            applications = [x for x in non_local_index if x == application_id]
        
        threads = [threading.Thread(target = get , args = (x,)) for x in applications]
        [x.start() for x in threads]
        [x.join() for x in threads]

        write_json("tmp/AppIndex.json" , index)

        if application_id is None:
            self.__index_update_time = time.time()


    def load_index(self):
        self.__index = read_json("tmp/AppIndex.json")
        self.__index_load_time = time.time()


'''app = AppIndexAPI("D:/EVERYTASK-USERS/")
app.update_local_index("daab4e71-5d60-4e18-b3cf-6f9a6a0da45b")
'''

'''
Architecture Developpement 
Text: {"type":"text" , "content:"Je suis un texte" , "font-size": 12 , "font-color":"red" , "font-options": ["underline"]}
DotList: {"type":"dotlist" , "content":["je","suis","une","liste","de","point"] , "font-size":12 , "font-color":"red" , "font-options":[]}
'''
"""

Herberger une api sur le raspberry pi
On créer une route pour check la clé, et pour uplaod l'application/ressource, le developpement
Port forwarding grace a https://portmap.io/




ARCH:

Everytask/
    versions/
        versions.json
        1.0.0/
        1.0.1/

Applications/

    1234-5678-1234-5678/
        IndexData/
            developpement.json
            reviews.json
            reports.json
            issues.json
        versions/
            1.0.0/
            1.0.1/
            versions.json
        config.json
    
    4321-8765-4321-8765/
        IndexData/
            developpement.json
            reviews.json
            reports.json
            issues.json
        versions/
            1.0.0/
            1.0.1/
            versions.json
        resources/
            handlers/
                1234-5678-1234-5678/
                4321-8765-4321-8765/
                index.json
            types.json        
    index.json

Local Index
id - name - author - description - search_tags - resources_types - resources - versions
"""

#api = AppIndexAPI("D:/EVERYTASK-USERS/")
#print(api.update_local_index())

#api = AppIndexAPI("D:/EVERYTASK-USERS")


#api = AppIndexAPI("D:/EVERYTASK-USERS/")
#api.new_review("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "1.0.0" , "Pas mal mais peut mieux faire" , "L'application est pas mal mais pourrait etre mieux" , 2 , "Elroy")
#api.new_review("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "1.0.1" , "Pas mal mais peut mieux faire" , "L'application est pas mal mais pourrait etre mieux" , 2 , "Elroy")
#print(api.get_reviews("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , version="1.0.0"))

#api.new_issue("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "1.0.0" , name = "Code Erreur 4045, l'interface a planté" , content = "Bonjour j'ai un problème avec le truc" , user = "Elroy" , display_name="Elroy")
#api.answer_issue("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "97d3bfef-c628-48f0-a61f-075086f4d16d" , "Bonjoru le problème vient de " , user = "Elroy" , display_name="Elroy")
#api.up_issue_answer("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "97d3bfef-c628-48f0-a61f-075086f4d16d" , "3688e1de-9d9f-4ea4-a839-10ebc25ca2af")


"""
Faire une option APPLIQUER CE CORRECTIF. On créer une architecture pour les réponses aux issues.
Par exemple il y a un bug dans le code. On pourrait répondre a ce bug avec cette architecture, et elle irait modifié les fichiers directmeent de manière local
On fait une copie avec correctif au cas ou
"""

#api = AppIndexAPI("D:/EVERYTASK-USERS/")
#api.new_review("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "1.0.0" , "Hey je suis Saligaud" , "Blablabla" , 2.5 , display_name="LeMecALavisQuiImportePeu..HaHA" , user="Saligaud")
#api = AppIndexAPI("D:/EVERYTASK-USERS/")
#print(api.get_reviews("d4d46336-2fa2-4dc8-ad52-58ef2178a06c" , "1.0.0"))